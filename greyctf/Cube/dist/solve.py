import gmpy2


p = 147271787827929374875021125075644322658199797362157810465584602627709052665153637157027284239972360505065250939071494710661089022260751215312981674288246413821920620065721158367282080824823494257083257784305248518512283466952090977840589689160607681176791401729705268519662036067738830529129470059752131312559
c = 117161008971867369525278118431420359590253064575766275058434686951139287312472337733007748860692306037011621762414693540474268832444018133392145498303438944989809563579460392165032736630619930502524106312155019251740588974743475569686312108671045987239439227420716606411244839847197214002961245189316124796380

#We need to simplift mathematically the process of cubing 
#So we can find a easy way to cube root the provess
#Modulo will not change even if its just res
#res = res % p
#Problem is now testing on inverse modulus 

def cuberoot(c,n,p):
	res = c
	for i in range(n):
	
		res = pow(gmpy2.mpz(res**(1/3)),-1,p)
		
		print(i/n)
	return res

#res= cuberoot(c,2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2 * 2**2 * 2**2 * 2,p)
res = cuberoot(c,2**100,p)
print("res : \t",res)
print(bytes.fromhex(hex(res)[2:]).decode())